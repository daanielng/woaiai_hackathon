"""
Refactored ConversationHandler into its own file for aesthetic purposes, also not so messy to clutter up the main codebase.
IMPT: For any subsequent Handlers/functions, please import run_in_threadpool_decorator and wrap it around your I/O blocking functions.
Eg.

@run_in_threadpool_decorator("blocking_function")
def function_that_blocks(some_input) -> None:
    # Some synchronous code
    return 0

async nonblocking_func() -> None:
    await function_that_blocks(some_input) # Spins up the function in a separate thread.
"""
import openai
import logging
from dotenv import dotenv_values
import json
from huggingface_hub import InferenceClient
from .utils import run_in_threadpool_decorator

from telegram import __version__ as TG_VER
from telegram import (
    Update,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
)
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
)

try:
    from telegram import __version_info__
except ImportError:
    __version_info__ = (0, 0, 0, 0, 0)  # type: ignore[assignment]

if __version_info__ < (20, 0, 0, "alpha", 1):
    raise RuntimeError(
        f"This example is not compatible with your current PTB version {TG_VER}. To view the "
        f"{TG_VER} version of this example, "
        f"visit https://docs.python-telegram-bot.org/en/v{TG_VER}/examples.html"
    )

# get config
config = dotenv_values(".env")
# get API tokens
HF_TOKEN = config["HF_API_KEY"]
openai.api_key = config["OPENAI_API_KEY"]
# TELEBOT_TOKEN = config['TELEBOT_TOKEN']
# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(processName)s - %(threadName)s - [%(thread)d] - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

# assign variable name for each integer in sequence for easy tracking of conversation

(
    IMAGE_TYPE,
    IMAGE_PURPOSE,
    SELECTED_THEME,
    SELECTED_IMAGE_DESIGN,
    TEXT_TO_IMAGE_PROMPT,
    GENERATED_IMAGE,
) = range(6)


# define helper function to get model's response
@run_in_threadpool_decorator("gpt_threads")
def get_completion(prompt, model="gpt-3.5-turbo") -> str:
    messages = [{"role": "user", "content": prompt}]
    response = openai.ChatCompletion.create(
        model=model,
        messages=messages,
        temperature=0,  # this is the degree of randomness of the model's output
    )
    logger.info(response)
    return response.choices[0].message["content"]


@run_in_threadpool_decorator("hugging_face_threads")
def txt2img(txt: str, image_path: str) -> None:
    client = InferenceClient(token=HF_TOKEN)
    image = client.text_to_image(txt)
    image.save(image_path)
    return 0


# function for /start command (CommandHandler type)
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Sends a message when the command /start is issued.
    """
    # get user
    user = update.effective_user

    # get username
    username = update.message.chat.username

    # get Chat ID
    chat_id = update.effective_chat.id

    # initialise cache for user
    context.user_data["image_info"] = {
        "image_type": None,
        "theme_output_json": None,
        "image_design_output_json": None,
        "user_selected_theme_val": None,
        "user_selected_image_design_val": None,
    }
    # store chat ID
    context.user_data["chat_id"] = chat_id

    # store username
    context.user_data["username"] = username

    # get list of image options for buttons
    buttons_lst = [["Poster"], ["Photography"], ["Illustration"]]

    # output keyboard markup for user to respond to
    await update.message.reply_html(
        f"Hi {user.mention_html()}, what type of image would you like to generate?\n\nSelect one of the options below:",
        reply_markup=ReplyKeyboardMarkup(buttons_lst),
    )
    return IMAGE_PURPOSE


# function to get user's input on the purpose of image
async def get_image_purpose(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Sends a message to ask for purpose of image type
    """
    # get previous input of user
    text = update.message.text

    # store users' input
    context.user_data["image_type"] = text.lower()

    # ask for purpose of image
    await update.message.reply_text(
        f"Type out the purpose of the {text.lower()}:\n(e.g. new housing estate in Bedok)",
        reply_markup=ReplyKeyboardRemove(),
    )
    return SELECTED_THEME


# function to select theme based on purpose of image (MessageHandler type)
async def select_theme(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Prompts chatgpt to generate themes and sends a message to ask user
    to select one of the themes generated by chatgpt.
    """
    # get user input (purpose of image)
    user_input = update.message.text

    # prompt chatgpt to generate themes
    prompt = (
        f"""
    You are a digital marketing AI assistant for a public housing company. 
    Suggest 5 poster themes for the following description: {user_input} in less than 20 words for each theme.
    Return the result in a JSON format, example:"""
        + r"""
    {1: result,
    2: result2,
    3: result3}"""
    )

    # get chatgpt's response
    response = await get_completion(prompt)
    themes = eval(response)

    # store results
    context.user_data["theme_output_json"] = themes

    # get list of suggested themes in KeyboardMarkup format
    buttons_lst = [[suggested_theme] for suggested_theme in themes.values()]

    # ask user for purpose of image
    await update.message.reply_text(
        f"Select one of the suggested themes below:",
        reply_markup=ReplyKeyboardMarkup(buttons_lst, resize_keyboard=True),
    )

    return SELECTED_IMAGE_DESIGN


# function to select image design based on selected theme
async def select_image_design(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """
    Prompts ChatGPT to generate image designs and sends a message to ask user
    to select one of the generated image designs.
    """
    # get user input (selection for theme of image)
    user_input = update.message.text

    # store user's input
    context.user_data["image_info"]["user_selected_theme_val"] = user_input

    # specify design attributes format for chatgpt
    design_attributes = {
        "image description": "none",
        "style of visual image": "none",
        "object in foreground description": "none",
    }

    # write the prompt to chatgpt
    prompt = (
        r"""
    You are a digital marketing AI assistant for a public housing company. 
    Given the theme of a poster delimited by ```, suggest 5 different outputs to replace "none" 
    for the specified design attributes provided in a JSON format delimited by ```.
    Keep in mind that the outputs must either be modern, futuristic, minimalistic, or stylish.
    Use '\'s' for any word that requires ```'s```, example: the house\'s window.

    Return the output in a JSON format, example:
    {'output_1': {
        'image description': "none",
        'style of visual image': "none",
        'object in foreground description': "none",
        },
    'output_2': {'image description': "none",
        'style of visual image': "none",
        'object in foreground description': "none",
        },
    'output_3': {'image description': "none",
        'style of visual image': "none",
        'object in foreground description': "none",
        }
    }"""
        + f"""
    theme: {user_input}
    design attributes: {design_attributes}"""
    )

    # get chatgpt's response
    response = await get_completion(prompt)
    image_designs_dict = eval(response)

    # store user's input
    context.user_data["image_info"]["image_design_output_json"] = image_designs_dict

    # get list of suggested image descriptions (to edit again for a better workflow)
    output_text = "\n"
    for output_id, output in image_designs_dict.items():
        # append output ID to string output
        output_text += f"Output {output_id[-1]}\n"

        # get each output description
        image_description = output["image description"]
        foreground_object = output["object in foreground description"]
        image_style = output["style of visual image"]

        # append each output description to string output
        image_design_text = (
            f"-> image description: {image_description}"
            + f"\n-> object in foreground: {foreground_object}"
            + f"\n-> style of image: {image_style}\n\n"
        )
        output_text += image_design_text

    # get list of suggested image design in KeyboardMarkup format
    buttons_lst = [[f"Output {val}"] for val in range(1, len(image_designs_dict) + 1)]

    # ask for purpose of image
    await update.message.reply_text(
        f"""
                                    Select one of the suggested image designs below:\n
                                    {output_text}
                                    """,
        reply_markup=ReplyKeyboardMarkup(buttons_lst, resize_keyboard=True),
    )

    return TEXT_TO_IMAGE_PROMPT


# function to get text-to-image prompt
async def get_image_prompt(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Generate text-to-image prompt based on selected image design
    """
    # get user input (selection for theme of image)
    user_input = update.message.text

    # store user's input
    context.user_data["image_info"]["user_selected_image_design_val"] = user_input

    # get cached results for image_type and selected image design
    selected_output_id = f"output_{user_input[-1]}"
    image_type = context.user_data["image_info"]["image_type"]

    for output_id, image_design_dict in context.user_data["image_info"][
        "image_design_output_json"
    ].items():
        # select image design dictionary based on user's selection
        if output_id == selected_output_id:
            selected_image_design_dict = image_design_dict
            break

    # initialise variables for gpt prompt
    style_image = selected_image_design_dict["style of visual image"]
    object_for_image = selected_image_design_dict["object in foreground description"]
    image_description = selected_image_design_dict["image description"]
    image_style = selected_image_design_dict["style of visual image"]

    design_attributes = {
        "colour palette": f"{style_image}",
        "type of image": f"{image_type}",
        "foreground of image": f"{image_description}",
        "props used in image": f"{object_for_image}",
        "style of image": f"{image_style}",
        "resolution": "8k",
    }

    sample_prompts = [
        "A still life of flowers, in the style of Jan van Huysum’s paintings, with a lush arrangement of blooms in a vase, surrounded by delicate butterflies, bees, and other insects.",
        "A digital collage of iconic tech gadgets, such as the iPhone, MacBook, and Amazon Echo, in the style of David Hockney.",
        "A surreal underwater world in the style of Salvador Dali, where all the sea creatures are actually different tech gadgets like iPhones, laptops, and smartwatches, floating amongst the seaweed and coral.",
        "A space station in the style of Stanley Kubrick’s 2001: A Space Odyssey, where all the spaceships and equipment are made of different popular candy bars like Snickers, Milky Way, and Three Musketeers, and all the astronauts are dressed as characters from Star Trek.",
        "A retro pop art-style illustration of the famous Hollywood sign, surrounded by colorful and iconic classic cars like the Corvette and the Mustang.",
        "A surreal, abstract landscape, inspired by Joan Miró’s paintings, with strange shapes, lines, and colors arranged in an imaginary world, with floating objects like planets and stars.",
        "main model shoot style, 8k 3d render sharp focus photography low angle shot high detail, beautiful Chinese fantasy woman portrait, teenage 23 years old, Looking at camera, fierce gaze, black lace textures, Michael parkes art, fantasy concept, 1379 Chiba imperial dynasty concubine. mythology, sleeveless gothic black gown, holding a dragon, red lips stained dripping honey, floral flower organic textures. realistic object octane Renders, outdoor lowlight moonlight dark dirty forest, dynamic lighting full length portrait, octane volumetric lighting, edge lighting, octane render, 8k, perfect shading, trending on artstation, ultra-realistic, concept art, Dark Mode, Tones of Black in Background, Spotlight, Beautiful cinematic shot + photos taken by ARRI, photos taken by sony, photos taken by canon, photos taken by nikon, photos taken by sony, photos taken by hasselblad + incredibly detailed, sharpen, details + professional lighting, photography lighting + 50mm, 80mm, 100m + lightroom gallery + behance photographys + unsplash –ar 2:3"
        "The Battle of Agincourt, 1415 - A bird’s eye view of the Battle of Agincourt, with English and French soldiers clashing on the battlefield and arrows raining down from the sky. In the style of Peter Paul Rubens’ Baroque battle scenes.",
        "A steampunk-inspired train station, where all the trains are made of different popular soda brands like Coca-Cola, Pepsi, and Dr. Pepper, and the passengers are robots and cyborgs.",
        "A spooky graveyard in the style of Edward Gorey, where all the tombstones and monuments are made of different popular cookies like Oreos, Chips Ahoy, and Nutter Butters, and all the ghosts are dressed as characters from The Addams Family.",
        "Create a photojournalistic-style image of Winston Smith as he starts to rebel against the oppressive government in George Orwell’s “1984.” Show him standing in front of a “Big Brother” poster, with a determined look on his face and the cityscape of Airstrip One in the background.",
        "Using a minimalist, sketch-like style, create an image of Holden Caulfield sitting on a bench in Central Park, New York, deep in thought as he contemplates the world around him. Show his melancholic expression and the cityscape behind him, with a backdrop of the wintry New York sky.",
        "Using a whimsical, fantasy-style illustration, create an image of Alice in Wonderland falling down the rabbit hole. Show her surrounded by fantastical creatures, with the White Rabbit peeking out from behind a tree and a sense of wonder and adventure in the air.",
    ]

    prompt = (
        r"""
    You are a digital marketing AI assistant for a public housing company. 
    Your task is to describe the image based on specified design attributes such as type, description 
    and styling of image which will be given in a JSON format.
    Follow the description structure as the list of sample image descriptions provided which are delimited by ```.
    Then, given the design attributes delimited by ``` , 
    describe the image as a prompt in a JSON format: {'prompt': generated_output}
    where the generated output will replace the space of 'generated_output'.
    Use '\'s' for any word that requires ```'s```, example: the house\'s window.
    
    To describe the image, do the following:
    - first, describe the image given the design attributes
    - second, compare your description with the sample image descriptions provided and 
    verify if your description structure is similar to the samples
    - lastly, if your image description is not similar, provide another image description given the design attributes, 
    following the description structure of the samples

    Use the following format:
    {'Your image description': image description here,
    'Is the sentence structure of your image description similar to the sample image descriptions': 'Yes or No',
    'Your final image description': final image description that has a similar sentence structure to the sample image descriptions,
    'prompt': final image description
    }
    """
        + f"""
    design attributes: ```{design_attributes}```
    sample image descriptions: ```{sample_prompts}```
    """
    )

    # get chatgpt's response
    response = await get_completion(prompt)
    image_prompt = eval(response)["prompt"]

    # cache generated prompt
    context.user_data["image_info"]["image prompt"] = image_prompt

    # Send image prompt to user for validation
    await update.message.reply_text(
        f"""
                                    Text-to-image Prompt:\n{image_prompt}\n\nClick the button to generate the image.\n(Please wait up to 2mins)
                                    """,
        reply_markup=ReplyKeyboardMarkup([["generate image"]], resize_keyboard=True),
    )
    return GENERATED_IMAGE


async def generate_image(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Generate image based on generated text-to-image prompt
    """
    # get username
    username = context.user_data["username"]

    # get generated prompt
    generated_prompt = context.user_data["image_info"]["image prompt"]

    update_as_dict = update.to_dict()
    update_as_json = json.dumps(update_as_dict)
    logger.info(update_as_json)
    logger.info(
        update_as_dict["message"]["from"]["first_name"]
        + " "
        + "sent the message of:"
        + update.message.text
    )
    # get first name
    first_name = update_as_dict["message"]["from"]["first_name"]

    # define image path
    image_path = f"data/image_output/{first_name}_output.png"

    # spin up another thread to await completion of huggingface API
    await txt2img(generated_prompt, image_path)

    await context.bot.send_photo(
        chat_id=context.user_data["chat_id"],
        photo=open(image_path, "rb"),
        write_timeout=150,
        caption=generated_prompt,
    )
    await update.message.reply_text(
        f"Do you want to start a new chat?",
        reply_markup=ReplyKeyboardMarkup([["/Yes"], ["/No"]]),
    )
    return IMAGE_TYPE


# function to cancel and end conversation (CommandHandler type)
async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Cancels and ends the conversation.
    """
    user = update.message.from_user
    logger.info("User %s canceled the conversation.", user.first_name)
    await update.message.reply_text(
        "Thank you and have a good day.", reply_markup=ReplyKeyboardRemove()
    )

    return ConversationHandler.END
